---
title: Load balancer com Cloudflare Worker + health check (de graÃ§a)
date: 2026-01-30
author: Yuri Cunha
description: Um load balancer gratuito usando Cloudflare Workers + Cloudflare Tunnel, com health check em intervalo e failover automÃ¡tico.
tags:
  - cloudflare
  - workers
  - tunnel
  - load-balancing
  - health-check
  - devops
  - javascript
---

O Cloudflare Load Balancer Ã© muito bom, mas Ã© um produto pago. Se o seu caso Ã© â€œtenho duas rÃ©plicas atrÃ¡s do Cloudflare Tunnel e quero failover automÃ¡tico se uma cairâ€, dÃ¡ pra resolver com um **Worker** (free tier) fazendo roteamento e health check.

A ideia Ã© simples:

- VocÃª cria **dois hostnames**, um por tÃºnel (primary e replica).
- VocÃª cria um **terceiro hostname** (o que vocÃª divulga) apontando pro Worker.
- O Worker verifica se os backends estÃ£o saudÃ¡veis e faz proxy para o melhor destino.

{/*more*/}

## Arquitetura (recomendada)

O padrÃ£o mais prÃ¡tico Ã© usar 3 hostnames:

- `service.seudominio.com`:
  - Aponta pro **Worker** (URL pÃºblica)
- `service-primary.seudominio.com`:
  - Cloudflare Tunnel apontando pro **servidor principal**
- `service-replica.seudominio.com`:
  - Cloudflare Tunnel apontando pro **servidor rÃ©plica**

Isso resolve aquele â€œproblemaâ€ comum do Tunnel: vocÃª nÃ£o consegue ter o *mesmo* hostname em mÃºltiplos tÃºneis, mas consegue ter hostnames diferentes e colocar o Worker na frente.

## Como o Worker funciona

- Ele mantÃ©m um cache em memÃ³ria chamado `serverHealth`, com:
  - `healthy`: Ãºltimo status conhecido
  - `lastCheck`: quando foi o Ãºltimo check
- A cada request:
  - Ele atualiza o health check se passou do `HEALTH_CHECK_INTERVAL`.
  - Ele escolhe o primeiro servidor saudÃ¡vel.
  - Se nenhum estiver saudÃ¡vel, ele cai no primeiro como fallback.
- Ele injeta o header `X-Served-By` pra debug.
- Se o `fetch` pro servidor escolhido der erro, ele tenta 1 vez no outro servidor.

Detalhe importante: esse cache fica na memÃ³ria do isolate do Worker. Ou seja, ele pode resetar em cold start e nÃ£o Ã© um â€œcache globalâ€ garantido. Pra failover simples, costuma ser suficiente.

## O cÃ³digo

Troque as URLs pelos seus tÃºneis.

```js
// Cloudflare Worker Load Balancer com Health Check
// Configure suas URLs dos tÃºneis aqui
const SERVERS = [
  {
    url: 'https://seu-tunel-1.seudominio.com',
    name: 'Server 1',
    healthCheckPath: '/health' // ou '/' se nÃ£o tiver endpoint especÃ­fico
  },
  {
    url: 'https://seu-tunel-2.seudominio.com',
    name: 'Server 2',
    healthCheckPath: '/health'
  }
]

// ConfiguraÃ§Ãµes
const HEALTH_CHECK_TIMEOUT = 5000 // 5 segundos
const HEALTH_CHECK_INTERVAL = 30000 // Checar a cada 30 segundos

// Cache de status dos servidores (mantido pelo Worker)
let serverHealth = {}

// FunÃ§Ã£o para fazer health check
async function checkHealth(server) {
  try {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), HEALTH_CHECK_TIMEOUT)

    const response = await fetch(server.url + server.healthCheckPath, {
      method: 'GET',
      signal: controller.signal,
      headers: {
        'User-Agent': 'Cloudflare-Worker-HealthCheck'
      }
    })

    clearTimeout(timeoutId)

    // Considera saudÃ¡vel se retornar 2xx ou 3xx
    return response.status >= 200 && response.status < 400
  } catch (error) {
    console.log(`Health check failed for ${server.name}:`, error.message)
    return false
  }
}

// FunÃ§Ã£o para obter servidor disponÃ­vel
async function getAvailableServer() {
  // Atualiza health check se necessÃ¡rio
  for (const server of SERVERS) {
    const lastCheck = serverHealth[server.url]?.lastCheck || 0
    const now = Date.now()

    if (now - lastCheck > HEALTH_CHECK_INTERVAL) {
      const isHealthy = await checkHealth(server)
      serverHealth[server.url] = {
        healthy: isHealthy,
        lastCheck: now
      }
    }
  }

  // Encontra servidor saudÃ¡vel
  for (const server of SERVERS) {
    if (serverHealth[server.url]?.healthy) {
      return server
    }
  }

  // Se nenhum estiver saudÃ¡vel, tenta o primeiro como fallback
  console.log('Nenhum servidor saudÃ¡vel encontrado, usando fallback')
  return SERVERS[0]
}

// Handler principal
export default {
  async fetch(request, env, ctx) {
    // Pega servidor disponÃ­vel
    const server = await getAvailableServer()

    // Cria nova URL mantendo o path original
    const url = new URL(request.url)
    const targetUrl = new URL(url.pathname + url.search, server.url)

    // Clona a requisiÃ§Ã£o para o servidor escolhido
    const modifiedRequest = new Request(targetUrl, {
      method: request.method,
      headers: request.headers,
      body: request.body,
      redirect: 'follow'
    })

    // Adiciona header para debug (opcional)
    modifiedRequest.headers.set('X-Served-By', server.name)

    try {
      // Faz a requisiÃ§Ã£o para o servidor
      const response = await fetch(modifiedRequest)

      // Clona a resposta para adicionar headers
      const newResponse = new Response(response.body, response)
      newResponse.headers.set('X-Served-By', server.name)

      return newResponse
    } catch (error) {
      // Se der erro, tenta o outro servidor
      console.log(`Erro ao acessar ${server.name}, tentando fallback`)

      const fallbackServer = SERVERS.find((s) => s.url !== server.url)
      if (fallbackServer) {
        const fallbackUrl = new URL(url.pathname + url.search, fallbackServer.url)
        const fallbackRequest = new Request(fallbackUrl, {
          method: request.method,
          headers: request.headers,
          body: request.body,
          redirect: 'follow'
        })

        return fetch(fallbackRequest)
      }

      return new Response('Todos os servidores estÃ£o indisponÃ­veis', { status: 503 })
    }
  }
}
```

## Como configurar (passo a passo)

1. **Crie dois hostnames de tÃºnel**

   - TÃºnel do principal: `service-primary.seudominio.com`
   - TÃºnel da rÃ©plica: `service-replica.seudominio.com`

2. **Crie o Worker**

   - Cloudflare Dashboard
   - Workers & Pages
   - Create Worker
   - Cole o cÃ³digo e atualize a lista `SERVERS`

3. **Aponte o hostname pÃºblico pro Worker**

   Crie uma rota (ou custom domain) pra que `service.seudominio.com/*` seja atendido por esse Worker.

4. **Testar qual servidor estÃ¡ respondendo**

   ```bash
   curl -I https://service.seudominio.com
   ```

   Procure pelo header `X-Served-By`.

5. **Testar o failover**

   Derrube o tunnel do principal por alguns segundos e faÃ§a a request de novo. O header deve mudar pra rÃ©plica.

## ObservaÃ§Ãµes e limitaÃ§Ãµes

- **ServiÃ§os com estado**: se o seu serviÃ§o grava estado em disco (sessÃµes, upload, histÃ³rico de chat, etc.), pense em storage compartilhado ou sincronizaÃ§Ã£o entre os nÃ³s.
- **Endpoint de health check**: prefira um endpoint bem leve (ou `/`) e evite checks â€œcarosâ€.
- **WebSockets / conexÃµes longas**: dependendo do plano e do comportamento do seu app, conexÃµes longas podem exigir ajustes.
- **Escopo do cache**: `serverHealth` fica em memÃ³ria do Worker e pode resetar. Se vocÃª precisar de algo mais consistente, dÃ¡ pra evoluir usando KV, Durable Objects ou monitoramento externo.

## Outra forma de fazer isso

VocÃª pode/consegue usar o mesmo Tunnel em dois servidores/serviÃ§os, entÃ£o basicamente, vocÃª poderia ter o Tunnel chamado "ServiÃ§os" e conectar ele no "Servidor A" e no "Servidor B".
Algumas pessoas acham essa soluÃ§Ã£o melhor, e em termos de cimplicidade, realmente ele Ã© melhor, mas se vocÃª quiser separar os Tunnels, atÃ© pra ter mais organizaÃ§Ã£o, o Worker Load Balancer Ã© melhor.

Mas caso vocÃª ainda queira um Tunnel em todos os seus servidores, segue o que eu percebi por que 1 Tunnel em TODAS as mÃ¡quinas Ã© uma MÃ IDEIA:
Se vocÃª usar 1 Tunnel compartilhado em todas as mÃ¡quinas:

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Tunnel "main"  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼           â–¼           â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Server A â”‚ â”‚Server B â”‚ â”‚Server C â”‚ â”‚Server D â”‚
â”‚         â”‚ â”‚         â”‚ â”‚         â”‚ â”‚         â”‚
â”‚Jellyfin â”‚ â”‚Navidromeâ”‚ â”‚qBittor. â”‚ â”‚OpenWebUIâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Problema: Cloudflare vai rotear jellyfin.dominio.com para QUALQUER servidor (A, B, C ou D aleatoriamente), mas o Jellyfin sÃ³ estÃ¡ no servidor A! ğŸ’¥
Resultado:

- 75% das requisiÃ§Ãµes vÃ£o dar erro 502 (caÃ­ram no servidor errado)
- VocÃª perde controle de onde cada serviÃ§o roda
- BagunÃ§a total

Funciona mas nÃ£o Ã© recomendado.

Nesse caso, O JEITO CERTO de usar replicas com um Ãºnico Tunnel seria UM Tunnel compartilhando APENAS quando o MESMO serviÃ§o que estÃ¡ em MÃšLTIPLAS mÃ¡quinas:

CenÃ¡rio 1: VocÃª quer failover do Open WebUI
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tunnel "openwebui"  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â–¼         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Server A â”‚ â”‚Server B â”‚
â”‚         â”‚ â”‚         â”‚  â† MESMO Open WebUI (PostgreSQL+Redis compartilhados)
â”‚OpenWebUIâ”‚ â”‚OpenWebUIâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Funciona, porque o Open WebUI estÃ¡ nos 2 servidores.

CenÃ¡rio 2: Jellyfin sÃ³ estÃ¡ em 1 servidor
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tunnel "media"   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚Server A â”‚
    â”‚         â”‚
    â”‚Jellyfin â”‚ â† SÃ³ aqui
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
âœ… Correto! Tunnel dedicado porque Jellyfin sÃ³ estÃ¡ em 1 lugar.

---

Resumo:

- 1 tunnel por mÃ¡quina: ServiÃ§os diferentes em mÃ¡quinas diferentes
- 1 tunnel em mÃºltiplas mÃ¡quinas: MESMO serviÃ§o replicado (failover)
1 tunnel em todas as mÃ¡quinas: NUNCA (a nÃ£o ser que TODOS os serviÃ§os estejam em TODAS as mÃ¡quinas)

## Lembre-te amigÃ¡vel

NÃ£o se esqueÃ§a que vocÃª precisa ter os dados sendo compartilhados e acessÃ­veis por todos os servidores, caso contrÃ¡rio vocÃª vai ter inconsistÃªncias nos dados. E atÃ© configuraÃ§Ãµes divergentes, ou ter que configurar cada um de forma diferente.
